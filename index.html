<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Force Directed Graph Demo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href='https://fonts.googleapis.com/css?family=Inter' rel='stylesheet'>
    <style>
        :root {
            --default-font: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Microsoft YaHei Light", sans-serif;
            --mermaid-font: var(--default-font);
            --reveal-font: var(--default-font);
            --font-monospace: 'Source Code Pro', monospace;
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        body {
            width: 100vw;
            height: 100vh;
            background: #222;
            overflow: hidden;
            margin-right: 320px; /* Add right margin to avoid overlap with sidebar */
            transition: margin-right 0.2s;
        }

        body.sidebar-minimized {
            margin-right: 32px;
        }

        svg {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        .link {
            stroke-width: 3px;
        }

        .node {
            stroke-width: 0;
            cursor: grab;
        }

        text {
            fill: #aaaab3;
            font-family: var(--default-font);
            pointer-events: none;
        }

        #sidebar {
            position: fixed;
            top: 0;
            right: 0;
            width: 320px;
            min-width: 180px;
            max-width: 600px;
            height: 100vh;
            background: #181818;
            color: #fff;
            border-left: 2px solid #444;
            z-index: 10;
            /*resize: horizontal;*/
            overflow: auto;
            box-sizing: border-box;
            padding: 16px 12px 12px 16px;
            transition: width 0.2s;
            display: flex;
            flex-direction: column;
            gap: 10px;
            font: 16px var(--default-font);
        }

        #sidebar.minimized {
            width: 0 !important;
            min-width: 0 !important;
            max-width: 0 !important;
            padding: 0 !important;
            border: none !important;
            overflow: hidden !important;
        }
        #sidebar.minimized > * {
            display: none !important;
        }

        #sidebar-toggle {
            position: fixed;
            top: 0;
            right: 320px;
            width: 56px;
            height: 56px;
            background: #222;
            color: #fff;
            border: none;
            border-right: 1px solid #444;
            cursor: pointer;
            z-index: 20;
            font-size: 24px;
            transition: right 0.2s;
        }

        body.sidebar-minimized #sidebar-toggle {
            right: 0;
        }

        #sidebar label {
            font-size: 15px;
            margin-top: 10px;
            display: block;
        }

        #sidebar input[type=range] {
            width: 90%;
            margin-bottom: 8px;
        }

        #node-search {
            width: 95%;
            margin-bottom: 10px;
            padding: 6px 6px;
            font-size: 15px;
            border-radius: 4px;
            border: 1px solid #444;
            background: #222;
            color: #fff;
            outline: none;
        }

        #search-results {
            max-height: 120px;
            overflow-y: auto;
            margin-bottom: 8px;
        }

        #search-results div {
            cursor: pointer;
            padding: 2px 0;
            font-size: 15px;
            color: #ffe;
        }

        #search-results div:hover {
            background: #333;
        }

        @media (max-width: 800px) {
            body {
                margin-right: 0 !important;
            }
            #sidebar {
                width: 100vw !important;
                min-width: 0 !important;
                max-width: 100vw !important;
                height: 100vh !important;
                left: 0 !important;
                right: 0 !important;
                top: 0 !important;
                border: none !important;
                border-left: none !important;
                padding: 24px 16px 16px 16px !important;
                font-size: 20px !important;
                z-index: 100 !important;
            }
            #sidebar-toggle {
                width: 96px !important;
                height: 96px !important;
                font-size: 48px !important;
                top: 12px !important;
                right: 12px !important;
                border-radius: 50% !important;
                z-index: 200 !important;
                background: #444 !important;
            }
            body.sidebar-minimized #sidebar-toggle {
                right: 12px !important;
            }
            #sidebar.minimized {
                width: 0 !important;
                min-width: 0 !important;
                max-width: 0 !important;
                padding: 0 !important;
                border: none !important;
                overflow: hidden !important;
            }
            #sidebar label, #sidebar h3, #sidebar input, #sidebar #search-results, #sidebar #node-description-container {
                font-size: 20px !important;
            }
            #node-search {
                font-size: 20px !important;
                padding: 12px 12px !important;
            }
        }
    </style>
</head>
<body>
<button id="sidebar-toggle">&lt;</button>
<div id="sidebar">
    <input id="node-search" type="text" placeholder="Search node...">
    <div id="search-results"></div>
    <h3>Force Settings</h3>
    <label for="center-force-slider">Center Force: <span id="center-force-value"></span></label>
    <input type="range" id="center-force-slider" min="0" max="0.2" step="0.001" value="0.068">
    <label for="repel-force-slider">Repel Force: <span id="repel-force-value"></span></label>
    <input type="range" id="repel-force-slider" min="0" max="1000" step="0.1" value="800">
    <label for="link-force-slider">Link Force: <span id="link-force-value"></span></label>
    <input type="range" id="link-force-slider" min="0" max="3" step="0.01" value="2.1">
    <label for="link-distance-slider">Link Distance: <span id="link-distance-value"></span></label>
    <input type="range" id="link-distance-slider" min="30" max="500" step="1" value="106">
    <hr style="margin: 16px 0 8px 0; border: none; border-top: 1px solid #444;">
    <div id="node-description-container" style="display:none;">
        <h4 id="node-name" style="margin:0 0 4px 0;"></h4>
        <div id="node-description" style="font-size:15px; color:#ffe; word-break:break-word;"></div>
    </div>
</div>
<svg></svg>
<script>
    // CONSTANTS
    // Node and link appearance
    const NODE_RADIUS = 20; // Default node radius
    const NODE_RADIUS_HOVER = 21; // Node radius on hover
    const NODE_BRIGHTEN_FACTOR = 1.2; // Factor to brighten node color when hovered
    const NODE_DARKEN_FACTOR = 0.5; // Factor to darken node color when not adjacent

    const LINK_BASE_COLOR = "#aaaab3"; // Base link color
    const LINK_BRIGHTEN_FACTOR = 2; // Factor to brighten link color when adjacent to hovered node
    const LINK_DARKEN_FACTOR = 0.5; // Factor to darken link color when not adjacent

    const LABEL_FONT_SIZE = 16; // Label font size in px
    const LABEL_OPACITY_DEFAULT = 0; // Default label opacity
    const LABEL_OPACITY_HOVER = 1; // Label opacity on hover
    const LABEL_OPACITY_HOVER_OTHER_MAX = 0.2;
    const LABEL_DY_DEFAULT = -28; // Default label vertical offset
    const LABEL_DY_HOVER = NODE_RADIUS - NODE_RADIUS_HOVER; // (Unused, but could be for label movement)
    const LABEL_DISPLAY = "block"; // Label display property

    // Simulation and zoom
    const ZOOM_MIN = 0.1; // Minimum zoom scale
    const ZOOM_MAX = 8; // Maximum zoom scale
    const ZOOM_OPACITY_MIN = 0.1; // Zoom level at which labels start to appear
    const ZOOM_OPACITY_MAX = 1; // Zoom level at which labels are fully visible
    const SIMULATION_ALPHA_ON_DRAG = 0.3; // Simulation alpha target on drag start
    const SIMULATION_ALPHA_ON_RESIZE = 0.5; // Simulation alpha on window resize

    const tags = {
        person: "#df5252", // green
        club: "#e0b152", // blue
        default: "#aaaab3" // fallback color
    };

    fetch('clubs_people.json')
        .then(response => {
            if (!response.ok) throw new Error('Failed to load data');
            return response.json();
        })
        .then(data => {
            if (!data.nodes || !data.links) throw new Error('data must have nodes and links arrays');
            initializeGraph(data.nodes, data.links);
        })
        .catch(err => {
            alert('Error loading data: ' + err.message);
        });

    function initializeGraph(nodes, links) {
        const svg = d3.select("svg"),
            width = window.innerWidth,
            height = window.innerHeight;

        // Add a group for zoom/pan
        const container = svg.append("g");

        // Add zoom behavior
        let currentZoom = 1;
        const zoomBehavior = d3.zoom()
            .scaleExtent([ZOOM_MIN, ZOOM_MAX])
            .on("zoom", (event) => {
                currentZoom = event.transform.k;
                container.attr("transform", event.transform);
                updateLabelsVisibility();
            });
        svg.call(zoomBehavior);

        // Forces
        const radialForce = d3.forceRadial(0, width / 2, height / 2).strength(0); // default strength
        const repelForce = d3.forceManyBody().strength(0); // default negative for repulsion
        const linkForce = d3.forceLink(links).id(d => d.id).distance(250).strength(0); // default values

        const simulation = d3.forceSimulation(nodes)
            .force("radial", radialForce)
            .force("link", linkForce)
            .force("charge", repelForce);

        const link = container.append("g")
            .selectAll("line")
            .data(links)
            .join("line")
            .attr("class", "link")
            .attr("stroke", LINK_BASE_COLOR)
            .attr("stroke-width", 3);

        const node = container.append("g")
            .selectAll("circle")
            .data(nodes)
            .join("circle")
            .attr("class", "node")
            .attr("r", NODE_RADIUS)
            .attr("fill", d => getNodeBaseColor(d))
            .style("opacity", 1)
            .call(drag(simulation));

        const label = container.append("g")
            .selectAll("text")
            .data(nodes)
            .join("text")
            .attr("text-anchor", "middle")
            .attr("dy", LABEL_DY_DEFAULT) // Place above the node
            .attr("dx", 0)
            .text(d => d.id)
            .style("opacity", LABEL_OPACITY_DEFAULT)
            .style("display", LABEL_DISPLAY)
            .style("font-size", LABEL_FONT_SIZE + "px");

        // Set default fill for nodes and stroke for links
        node.attr("fill", d => getNodeBaseColor(d)).style("opacity", 1);
        link.attr("stroke", LINK_BASE_COLOR);

        // Utility: brighten/darken color using HSL
        function adjustColorBrightness(hex, factor) {
            // Convert hex to RGB
            let r = parseInt(hex.slice(1, 3), 16);
            let g = parseInt(hex.slice(3, 5), 16);
            let b = parseInt(hex.slice(5, 7), 16);
            // Convert to HSL
            r /= 255;
            g /= 255;
            b /= 255;
            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max === min) {
                h = s = 0;
            } else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r:
                        h = (g - b) / d + (g < b ? 6 : 0);
                        break;
                    case g:
                        h = (b - r) / d + 2;
                        break;
                    case b:
                        h = (r - g) / d + 4;
                        break;
                }
                h /= 6;
            }
            // Adjust lightness (additive instead of multiplicative for more visible effect)
            l = Math.max(0, Math.min(1, l + (factor - 1) * 0.5));
            // Convert back to RGB
            let hue2rgb = function (p, q, t) {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1 / 6) return p + (q - p) * 6 * t;
                if (t < 1 / 2) return q;
                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                return p;
            };
            let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            let p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
            r = Math.round(r * 255);
            g = Math.round(g * 255);
            b = Math.round(b * 255);
            return `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
        }

        // Helper to get node color by tag
        function getNodeBaseColor(node) {
            return tags[node.tag] || tags.default;
        }

        // Show label on hover, hide on mouseout (unless zoomed in)
        node.on("mouseover", function (event, d) {
            // Instantly show label and move it up
            d3.select(label.nodes()[nodes.indexOf(d)])
                .style("opacity", LABEL_OPACITY_HOVER)
                .attr("dy", LABEL_DY_DEFAULT + LABEL_DY_HOVER);
            // Expand node on hover
            d3.select(this)
                .attr("r", NODE_RADIUS_HOVER);
            // Find immediate neighbors
            const neighborIds = new Set([d.id]);
            links.forEach(l => {
                if ((l.source.id ? l.source.id : l.source) === d.id) neighborIds.add(l.target.id ? l.target.id : l.target);
                if ((l.target.id ? l.target.id : l.target) === d.id) neighborIds.add(l.source.id ? l.source.id : l.source);
            });
            // Set node fill and radius: hovered node, immediate, rest
            node
                .attr("r", n => n.id === d.id ? NODE_RADIUS_HOVER : NODE_RADIUS)
                .attr("fill", n => n.id === d.id
                    ? adjustColorBrightness(getNodeBaseColor(n), NODE_BRIGHTEN_FACTOR)
                    : neighborIds.has(n.id)
                        ? getNodeBaseColor(n)
                        : adjustColorBrightness(getNodeBaseColor(n), NODE_DARKEN_FACTOR))
                .style("opacity", 1);
            // Set link color: links connected to hovered node, rest
            link
                .attr("stroke", l => (l.source.id ? l.source.id : l.source) === d.id || (l.target.id ? l.target.id : l.target) === d.id
                    ? adjustColorBrightness(LINK_BASE_COLOR, LINK_BRIGHTEN_FACTOR)
                    : adjustColorBrightness(LINK_BASE_COLOR, LINK_DARKEN_FACTOR));
            // Set label opacity: hovered node label full, adjacent node labels medium, others use zoom-based opacity
            const zoomOpacity = getZoomOpacity(currentZoom);
            label
                .style("opacity", (n) => n.id === d.id ? LABEL_OPACITY_HOVER : neighborIds.has(n.id) ? 0.7 : Math.min(zoomOpacity, LABEL_OPACITY_HOVER_OTHER_MAX))
                .attr("dy", (n) => n.id === d.id ? LABEL_DY_DEFAULT + LABEL_DY_HOVER : LABEL_DY_DEFAULT);
        });
        node.on("mouseout", function (event, d) {
            // Instantly restore label opacity to zoom-based value and move it back
            const zoomOpacity = getZoomOpacity(currentZoom);
            d3.select(label.nodes()[nodes.indexOf(d)])
                .style("opacity", zoomOpacity)
                .attr("dy", LABEL_DY_DEFAULT);
            // Shrink node back to normal
            d3.select(this)
                .attr("r", NODE_RADIUS);
            // Restore all nodes and links to default fill, stroke, and radius
            node
                .attr("r", NODE_RADIUS)
                .attr("fill", n => getNodeBaseColor(n))
                .style("opacity", 1);
            link
                .attr("stroke", LINK_BASE_COLOR);
            // Restore all labels to zoom-based opacity and default dy
            label
                .style("opacity", zoomOpacity)
                .attr("dy", LABEL_DY_DEFAULT);
        });

        function getZoomOpacity(zoom) {
            // Opacity ramps from 0 at zoom=1 to 1 at zoom=2
            return Math.max(0, Math.min(1, (zoom - ZOOM_OPACITY_MIN) / (ZOOM_OPACITY_MAX - ZOOM_OPACITY_MIN)));
        }

        function updateLabelsVisibility() {
            // Instantly set opacity based on zoom
            const zoomOpacity = getZoomOpacity(currentZoom);
            label.style("opacity", zoomOpacity).attr("dy", LABEL_DY_DEFAULT);
        }

        simulation.on("tick", () => {
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            node
                .attr("cx", d => d.x)
                .attr("cy", d => d.y);

            label
                .attr("x", d => d.x)
                .attr("y", d => d.y);
        });

        function drag(simulation) {
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(SIMULATION_ALPHA_ON_DRAG).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }

            return d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended);
        }

        // Make the SVG responsive to window resizing
        window.addEventListener('resize', () => {
            const w = window.innerWidth;
            const h = window.innerHeight;
            svg.attr('width', w).attr('height', h);
            // Update radial force center and radius
            radialForce.x(w / 2).y(h / 2).radius(Math.min(w, h) / 2);
            simulation.alpha(SIMULATION_ALPHA_ON_RESIZE).restart();
        });

        // Sidebar logic
        const sidebar = document.getElementById('sidebar');
        const sidebarToggle = document.getElementById('sidebar-toggle');
        const centerForceSlider = document.getElementById('center-force-slider');
        const repelForceSlider = document.getElementById('repel-force-slider');
        const linkForceSlider = document.getElementById('link-force-slider');
        const linkDistanceSlider = document.getElementById('link-distance-slider');
        const centerForceValue = document.getElementById('center-force-value');
        const repelForceValue = document.getElementById('repel-force-value');
        const linkForceValue = document.getElementById('link-force-value');
        const linkDistanceValue = document.getElementById('link-distance-value');
        const searchInput = document.getElementById('node-search');
        const searchResults = document.getElementById('search-results');

        function updateSidebarValues() {
            centerForceValue.textContent = centerForceSlider.value;
            repelForceValue.textContent = repelForceSlider.value;
            linkForceValue.textContent = linkForceSlider.value;
            linkDistanceValue.textContent = linkDistanceSlider.value;
        }

        updateSidebarValues();

        // Set initial force values from sliders on page load
        radialForce.strength(+centerForceSlider.value);
        repelForce.strength(-Math.abs(+repelForceSlider.value));
        linkForce.strength(+linkForceSlider.value);
        linkForce.distance(+linkDistanceSlider.value);
        simulation.alpha(0.5).restart();

        centerForceSlider.addEventListener('input', function () {
            radialForce.strength(+this.value);
            simulation.alpha(0.5).restart();
            updateSidebarValues();
        });
        repelForceSlider.addEventListener('input', function () {
            repelForce.strength(-Math.abs(+this.value)); // always negative for repulsion
            simulation.alpha(0.5).restart();
            updateSidebarValues();
        });
        linkForceSlider.addEventListener('input', function () {
            linkForce.strength(+this.value);
            simulation.alpha(0.5).restart();
            updateSidebarValues();
        });
        linkDistanceSlider.addEventListener('input', function () {
            linkForce.distance(+this.value);
            simulation.alpha(0.5).restart();
            updateSidebarValues();
        });

        // Debounce utility
        function debounce(fn, delay) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => fn.apply(this, args), delay);
            };
        }

        // Debounced force slider handlers
        centerForceSlider.addEventListener('input', debounce(function () {
            radialForce.strength(+this.value);
            simulation.alpha(0.5).restart();
            updateSidebarValues();
        }, 200));
        repelForceSlider.addEventListener('input', debounce(function () {
            repelForce.strength(-Math.abs(+this.value));
            simulation.alpha(0.5).restart();
            updateSidebarValues();
        }, 200));
        linkForceSlider.addEventListener('input', debounce(function () {
            linkForce.strength(+this.value);
            simulation.alpha(0.5).restart();
            updateSidebarValues();
        }, 200));
        linkDistanceSlider.addEventListener('input', debounce(function () {
            linkForce.distance(+this.value);
            simulation.alpha(0.5).restart();
            updateSidebarValues();
        }, 200));

        sidebarToggle.addEventListener('click', function () {
            sidebar.classList.toggle('minimized');
            document.body.classList.toggle('sidebar-minimized');
            sidebarToggle.textContent = sidebar.classList.contains('minimized') ? '>' : '<';
        });

        // Node click: show description in sidebar
        node.on("click", function(event, d) {
            const descContainer = document.getElementById('node-description-container');
            const descDiv = document.getElementById('node-description');
            const nameDiv = document.getElementById('node-name');
            nameDiv.textContent = d.id;
            let html = '';
            if (d.tag === 'person' && d.data) {
                html += '<b>Club Roles:</b><ul style="margin:0 0 8px 0;">';
                for (const [club, roles] of Object.entries(d.data)) {
                    html += `<li><b>${club}:</b> ${roles.join(', ')}</li>`;
                }
                html += '</ul>';
            } else if (d.tag === 'club' && d.data) {
                if (d.data.desc_short) {
                    html += `<div style='margin-bottom:8px;'><b>Description:</b> ${d.data.desc_short}</div>`;
                }
                if (d.data.committee) {
                    html += '<b>Committee:</b><ul style="margin:0;">';
                    for (const [role, people] of Object.entries(d.data.committee)) {
                        html += `<li><b>${role}:</b> ${people.join(', ')}</li>`;
                    }
                    html += '</ul>';
                }
            } else {
                html = '(No data)';
            }
            descDiv.innerHTML = html;
            descContainer.style.display = '';
            // If sidebar is minimized, open it
            if (sidebar.classList.contains('minimized')) {
                sidebar.classList.remove('minimized');
                document.body.classList.remove('sidebar-minimized');
                sidebarToggle.textContent = '<';
            }
        });
        // Optional: clicking background hides description
        svg.on('click', function(event) {
            if (event.target === svg.node()) {
                document.getElementById('node-description-container').style.display = 'none';
            }
        });

        // Search bar logic
        searchInput.addEventListener('input', function() {
            const query = this.value.trim().toLowerCase();
            searchResults.innerHTML = '';
            if (!query) return;
            const matches = nodes.filter(n => n.id.toLowerCase().includes(query));
            if (matches.length === 0) {
                searchResults.innerHTML = '<div style="color:#aaa;font-size:14px;">No results</div>';
                return;
            }
            matches.slice(0, 20).forEach(n => {
                const div = document.createElement('div');
                div.textContent = n.id;
                div.style.cursor = 'pointer';
                div.style.padding = '2px 0';
                div.style.fontSize = '15px';
                div.style.color = '#ffe';
                div.addEventListener('click', function(e) {
                    node.filter(d => d.id === n.id).dispatch('click');
                    centerViewOnNode(n);
                    searchResults.innerHTML = '';
                    searchInput.value = '';
                });
                searchResults.appendChild(div);
            });
        });
        // Select top result on Enter
        searchInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                const query = this.value.trim().toLowerCase();
                if (!query) return;
                const matches = nodes.filter(n => n.id.toLowerCase().includes(query));
                if (matches.length === 0) return;
                const n = matches[0];
                node.filter(d => d.id === n.id).dispatch('click');
                centerViewOnNode(n);
                searchResults.innerHTML = '';
                searchInput.value = '';
            }
        });

        // Helper to center view on a node
        function centerViewOnNode(n) {
            if (typeof n.x !== 'number' || typeof n.y !== 'number') return;
            const svgEl = d3.select('svg');
            const w = window.innerWidth, h = window.innerHeight;
            const k = d3.zoomTransform(svgEl.node()).k;
            const tx = w / 2 - n.x * k;
            const ty = h / 2 - n.y * k;
            svgEl.transition().duration(400).call(
                zoomBehavior.transform,
                d3.zoomIdentity.translate(tx, ty).scale(k)
            );
        }

        updateLabelsVisibility();
    }
</script>
</body>
</html>
